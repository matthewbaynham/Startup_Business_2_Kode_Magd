using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Excel = Microsoft.Office.Interop.Excel;
using System.Windows.Forms;
using VBA = Microsoft.Vbe.Interop;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text.RegularExpressions;
using KodeMagd.Misc;

namespace KodeMagd.InsertCode
{
    public class ClsInsertCode
    {
        private bool bUsingWithStatement = false;
        //private ClsCodeMapperWrk cCodeMapperWrk;
        private const string csSampleFunctionNamePrefix = "SampleCode";

        public enum enumPosition 
        {
            ePosBeginning,
            ePosBeginningAfterOptions,
            ePosEnd,
            ePosCurrent
        }

        public enum enumFormatLineCutMethodology 
        {
            eFmtLineCut_None,
            eFmtLineCut_AfterXChar,
            eFmtLineCut_AtFirstBracket
        }

        //public struct strLineOut 
        //{
        //    public int iOrder;
        //    public string sLine;
        //}

        private Excel.Application app;
        VBA.VBProject VBProj;

        public bool UsingWith
        {
            get
            {
                try
                {
                    ClsSettings cSettings = new ClsSettings();

                    bool bUsingWith = cSettings.UseWith;

                    cSettings = null;

                    return bUsingWith;
                }
                catch (Exception ex)
                {
                    MethodBase mbTemp = MethodBase.GetCurrentMethod();

                    string sMessage = string.Empty;

                    sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                    sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                    sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                    sMessage += ex.Message;

                    MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                    return false;
                }
            }
        }
        
        public ClsInsertCode() 
        {
            try
            {
                //cCodeMapperWrk = new ClsCodeMapperWrk();
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void add_reference(string sText) 
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                if (!ClsMisc.referenceOK(vbComp.VBE.ActiveVBProject, sText))
                {
                    FrmInstructions frm = new FrmInstructions(FrmInstructions.enumInstructionType.eAddingReference, "Microsoft ActiveX Data Object");

                    frm.ShowDialog();

                    frm = null;
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addTitleComment(ref List<string> lstLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                string sDate = DateTime.Now.ToString();

                string sUser = Environment.UserName;

                lstLines.Add(cSettings.Indent(iIndent));

                lstLines.Add(cSettings.Indent(iIndent) + "' ************************************************ ");
                lstLines.Add(cSettings.Indent(iIndent) + "' *        Code generated by " + ClsMiscString.Left(ClsMisc.gcsAppName + "                         ", 20) + "*");
                lstLines.Add(cSettings.Indent(iIndent) + "' *        " + ClsMiscString.Left("Version: " + Assembly.GetExecutingAssembly().GetName().Version.ToString() + "                                     ", 38) + "*");
                lstLines.Add(cSettings.Indent(iIndent) + "' *        " + ClsMiscString.Left(ClsMisc.gcsAppWebsite + "                                     ", 38) + "*");
                lstLines.Add(cSettings.Indent(iIndent) + "' ************************************************ ");
                lstLines.Add(cSettings.Indent(iIndent) + "'");
                lstLines.Add(cSettings.Indent(iIndent) + "' On " + sDate);
                lstLines.Add(cSettings.Indent(iIndent) + "' By " + sUser);

                lstLines.Add(cSettings.Indent(iIndent));
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addTitleComment(ref ClsLinesOutputRapper cLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                string sDate = DateTime.Now.ToString();

                string sUser = Environment.UserName;

                cLines.Add(cSettings.Indent(iIndent));

                cLines.Add(cSettings.Indent(iIndent) + "' ************************************************ ");
                cLines.Add(cSettings.Indent(iIndent) + "' *        Code generated by " + ClsMiscString.Left(ClsMisc.gcsAppName + "                         ", 20) + "*");
                cLines.Add(cSettings.Indent(iIndent) + "' ************************************************ ");
                cLines.Add(cSettings.Indent(iIndent) + "'");
                cLines.Add(cSettings.Indent(iIndent) + "' On " + sDate);
                cLines.Add(cSettings.Indent(iIndent) + "' By " + sUser);

                cLines.Add(cSettings.Indent(iIndent));
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerCall(ref List<string> lstLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                if (cSettings.InsertErrorHandlers)
                {
                    addErrorHandlerCallNoCheck(ref lstLines, ref cSettings, iIndent);
                    //lstLines.Add(cSettings.Indent(iIndent) + "On Error Goto ErrHandler");
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerCallNoCheck(ref List<string> lstLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                lstLines.Add(cSettings.Indent(iIndent) + "On Error Goto ErrHandler");
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerCall(ref ClsLinesOutputRapper cLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                if (cSettings.InsertErrorHandlers)
                {
                    addErrorHandlerCallNoCheck(ref cLines, ref cSettings, iIndent);
                    //cLines.Add(cSettings.Indent(iIndent) + "On Error Goto ErrHandler");
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerCallNoCheck(ref ClsLinesOutputRapper cLines, ref ClsSettings cSettings, int iIndent)
        {
            try
            {
                cLines.Add(cSettings.Indent(iIndent) + "On Error Goto ErrHandler");
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerBody(ref List<string> lstLines, ref ClsSettings cSettings, int iIndent, ClsCodeMapper.enumFunctionType eFunctionType)
        {
            try
            {
                if (cSettings.InsertErrorHandlers)
                {
                    addErrorHandlerBodyNoCheck(ref lstLines, ref cSettings, iIndent, eFunctionType);
                    /*
                    switch (eFunctionType)
                    {
                        case ClsCodeMapper.enumFunctionType.eFnType_Function:
                            lstLines.Add(cSettings.Indent(iIndent) + "Exit Function");
                            break;
                        case ClsCodeMapper.enumFunctionType.eFnType_Property:
                            lstLines.Add(cSettings.Indent(iIndent) + "Exit Property");
                            break;
                        case ClsCodeMapper.enumFunctionType.eFnType_Sub:
                            lstLines.Add(cSettings.Indent(iIndent) + "Exit Sub");
                            break;
                        default:
                            break;
                    }
                    lstLines.Add(cSettings.Indent(iIndent) + "ErrHandler:");
                    lstLines.Add(cSettings.Indent(iIndent) + "MsgBox Err.Description, vbCritical, \"Error No. \" & CStr(Err.Number)");
                    */ 
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerBodyNoCheck(ref List<string> lstLines, ref ClsSettings cSettings, int iIndent, ClsCodeMapper.enumFunctionType eFunctionType)
        {
            try
            {
                switch (eFunctionType)
                {
                    case ClsCodeMapper.enumFunctionType.eFnType_Function:
                        lstLines.Add(cSettings.Indent(iIndent) + "Exit Function");
                        break;
                    case ClsCodeMapper.enumFunctionType.eFnType_Property:
                        lstLines.Add(cSettings.Indent(iIndent) + "Exit Property");
                        break;
                    case ClsCodeMapper.enumFunctionType.eFnType_Sub:
                        lstLines.Add(cSettings.Indent(iIndent) + "Exit Sub");
                        break;
                    default:
                        break;
                }
                lstLines.Add(cSettings.Indent(iIndent) + "ErrHandler:");
                lstLines.Add(cSettings.Indent(iIndent) + "MsgBox Err.Description, vbCritical, \"Error No. \" & CStr(Err.Number)");
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerBody(ref ClsLinesOutputRapper cLines, ref ClsSettings cSettings, int iIndent, ClsCodeMapper.enumFunctionType eFunctionType)
        {
            try
            {
                if (cSettings.InsertErrorHandlers)
                {
                    addErrorHandlerBodyNoCheck(ref cLines, ref cSettings, iIndent, eFunctionType);
                    /*
                    switch (eFunctionType)
                    {
                        case ClsCodeMapper.enumFunctionType.eFnType_Function:
                            cLines.Add(cSettings.Indent(iIndent) + "Exit Function");
                            break;
                        case ClsCodeMapper.enumFunctionType.eFnType_Property:
                            cLines.Add(cSettings.Indent(iIndent) + "Exit Property");
                            break;
                        case ClsCodeMapper.enumFunctionType.eFnType_Sub:
                            cLines.Add(cSettings.Indent(iIndent) + "Exit Sub");
                            break;
                        default:
                            break;
                    }
                    cLines.Add(cSettings.Indent(iIndent) + "ErrHandler:");
                    cLines.Add(cSettings.Indent(iIndent) + "MsgBox Err.Description, vbCritical, \"Error No. \" & CStr(Err.Number)");
                    */
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addErrorHandlerBodyNoCheck(ref ClsLinesOutputRapper cLines, ref ClsSettings cSettings, int iIndent, ClsCodeMapper.enumFunctionType eFunctionType)
        {
            try
            {
                switch (eFunctionType)
                {
                    case ClsCodeMapper.enumFunctionType.eFnType_Function:
                        cLines.Add(cSettings.Indent(iIndent) + "Exit Function");
                        break;
                    case ClsCodeMapper.enumFunctionType.eFnType_Property:
                        cLines.Add(cSettings.Indent(iIndent) + "Exit Property");
                        break;
                    case ClsCodeMapper.enumFunctionType.eFnType_Sub:
                        cLines.Add(cSettings.Indent(iIndent) + "Exit Sub");
                        break;
                    default:
                        break;
                }
                cLines.Add(cSettings.Indent(iIndent) + "ErrHandler:");
                cLines.Add(cSettings.Indent(iIndent) + "MsgBox Err.Description, vbCritical, \"Error No. \" & CStr(Err.Number)");
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        //public void addErrorHandlerBody(ref List<strLineOut> lstLines, ref ClsSettings cSettings, int iIndent, ClsCodeMapper.enumFunctionType eFunctionType)
        //{
        //    try
        //    {
        //        if (cSettings.InsertErrorHandlers)
        //        {
        //            strLineOut objLineOut = new strLineOut();
        //            int iOrder = lstLines.Max(x => x.iOrder);

        //            iOrder++;
        //            objLineOut.iOrder = iOrder;

        //            switch (eFunctionType)
        //            {
        //                case ClsCodeMapper.enumFunctionType.eFnType_Function:
        //                    objLineOut.sLine = cSettings.Indent(iIndent) + "Exit Function";

        //                    lstLines.Add(objLineOut);
        //                    break;
        //                case ClsCodeMapper.enumFunctionType.eFnType_Property:
        //                    objLineOut.sLine = cSettings.Indent(iIndent) + "Exit Property";

        //                    lstLines.Add(objLineOut);
        //                    break;
        //                case ClsCodeMapper.enumFunctionType.eFnType_Sub:
        //                    objLineOut.sLine = cSettings.Indent(iIndent) + "Exit Sub";

        //                    lstLines.Add(objLineOut);
        //                    break;
        //                default:
        //                    break;
        //            }
        //            iOrder++;
        //            objLineOut.iOrder = iOrder;
        //            objLineOut.sLine = cSettings.Indent(iIndent) + "ErrHandler:";
        //            lstLines.Add(objLineOut);

        //            iOrder++;
        //            objLineOut.iOrder = iOrder;
        //            objLineOut.sLine = cSettings.Indent(iIndent) + "MsgBox Err.Description, vbCritical, \"Error No. \" & CStr(Err.Number)";
        //            lstLines.Add(objLineOut);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        MethodBase mbTemp = MethodBase.GetCurrentMethod();

        //        string sMessage = string.Empty;

        //        sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
        //        sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
        //        sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
        //        sMessage += ex.Message;

        //        MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
        //    }
        //}

        public void addCode(ref List<string> lstLines)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref lstLines, ref vbComp);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref cLines, ref vbComp);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref List<string> lstLines, enumPosition ePosition)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref lstLines, ref vbComp, ePosition);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines, enumPosition ePosition)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref cLines, ref vbComp, ePosition);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref List<string> lstLines, ref VBA.VBComponent VBComp)
        {
            try
            {
                addCode(ref lstLines, ref VBComp, enumPosition.ePosCurrent);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines, ref VBA.VBComponent VBComp)
        {
            try
            {
                addCode(ref cLines, ref VBComp, enumPosition.ePosCurrent);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref List<string> lstLines, ref VBA.VBComponent VBComp, enumPosition ePosition)
        {
            try
            {
                fixedReturnCharactors(ref lstLines);

                VBA.CodePane objCodePane = VBComp.CodeModule.CodePane;
                int iLinePos = 0;

                switch (ePosition)
                {
                    case enumPosition.ePosCurrent:
                        int iStartLine = 0;
                        int iStartColumn = 0;
                        int iEndLine = 0;
                        int iEndColumn = 0;

                        objCodePane.GetSelection(out iStartLine, out iStartColumn, out iEndLine, out iEndColumn);

                        string sCodeLine = objCodePane.CodeModule.get_Lines(iStartLine, 1);
                        string sCodeLineBegin = ClsMiscString.Left(ref sCodeLine, iStartColumn - 1);
                        string sCodeLineEnd = ClsMiscString.Right(ref sCodeLine, sCodeLine.Length - sCodeLineBegin.Length);

                        iLinePos = iStartLine;
                        if (objCodePane.CodeModule.CountOfLines > 0 & iLinePos < objCodePane.CodeModule.CountOfLines)
                        { objCodePane.CodeModule.DeleteLines(iLinePos, 1); }
                        objCodePane.CodeModule.InsertLines(iLinePos, sCodeLineEnd);
                        objCodePane.CodeModule.InsertLines(iLinePos, sCodeLineBegin);

                        checkNotAboveOptionLines(ref objCodePane, ref iLinePos);

                        iLinePos++;

                        addLines(ref lstLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosBeginning:
                        iLinePos = 0;

                        addLines(ref lstLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosBeginningAfterOptions:
                        iLinePos = ClsMisc.findFirstLineExcludingOptions(ref objCodePane);

                        addLines(ref lstLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosEnd:
                        iLinePos = objCodePane.CodeModule.CountOfLines;

                        addLines(ref lstLines, ref objCodePane, ref iLinePos);
                        break;
                    default:
                        break;
                }
                if (iLinePos == 0)
                { objCodePane.SetSelection(1, 1, 1, 1); }
                else
                { objCodePane.SetSelection(iLinePos, 1, iLinePos, 1); }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines, ref VBA.VBComponent VBComp, enumPosition ePosition)
        {
            try
            {
                fixedReturnCharactors(ref cLines);

                VBA.CodePane objCodePane = VBComp.CodeModule.CodePane;
                int iLinePos = 0;

                switch (ePosition)
                {
                    case enumPosition.ePosCurrent:
                        int iStartLine = 0;
                        int iStartColumn = 0;
                        int iEndLine = 0;
                        int iEndColumn = 0;

                        objCodePane.GetSelection(out iStartLine, out iStartColumn, out iEndLine, out iEndColumn);

                        string sCodeLine = objCodePane.CodeModule.get_Lines(iStartLine, 1);
                        string sCodeLineBegin = ClsMiscString.Left(ref sCodeLine, iStartColumn - 1);
                        string sCodeLineEnd = ClsMiscString.Right(ref sCodeLine, sCodeLine.Length - sCodeLineBegin.Length);

                        iLinePos = iStartLine;
                        if (objCodePane.CodeModule.CountOfLines > 0 & iLinePos < objCodePane.CodeModule.CountOfLines)
                        { objCodePane.CodeModule.DeleteLines(iLinePos, 1); }
                        objCodePane.CodeModule.InsertLines(iLinePos, sCodeLineEnd);
                        objCodePane.CodeModule.InsertLines(iLinePos, sCodeLineBegin);

                        checkNotAboveOptionLines(ref objCodePane, ref iLinePos);

                        iLinePos++;

                        addLines(ref cLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosBeginning:
                        iLinePos = 0;

                        addLines(ref cLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosBeginningAfterOptions:
                        iLinePos = ClsMisc.findFirstLineExcludingOptions(ref objCodePane);

                        addLines(ref cLines, ref objCodePane, ref iLinePos);
                        break;
                    case enumPosition.ePosEnd:
                        iLinePos = objCodePane.CodeModule.CountOfLines;

                        addLines(ref cLines, ref objCodePane, ref iLinePos);
                        break;
                    default:
                        break;
                }
                if (iLinePos == 0)
                { objCodePane.SetSelection(1, 1, 1, 1); }
                else
                { objCodePane.SetSelection(iLinePos, 1, iLinePos, 1); }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void checkNotAboveOptionLines(ref VBA.CodePane objCodePane, ref int iLineNumber)
        {
            try
            {
                //calculate line no of first line which is function
                //if currect line is less check if there are any options lines between current line and 

                bool bIsDone = false;
                int iLineTemp = 0;
                int iLineFirstFunction = 0;
                int iLineLastOption = 0;

                List<string> lstLines = objCodePane.CodeModule.get_Lines(1, objCodePane.CodeModule.CountOfLines).Split(new string[] { "\r\n" }, StringSplitOptions.None).ToList();

                while (bIsDone == false)
                {
                    if (iLineTemp < lstLines.Count)
                    {
                        string sTemp = lstLines[iLineTemp].Trim().ToUpper();

                        /*
                         include declaring DLL function things and declaring variables.
                         
                         */

                        if (!(sTemp == "" || sTemp.StartsWith("'") || sTemp.StartsWith("REM", StringComparison.CurrentCultureIgnoreCase) || sTemp.StartsWith("OPTION ", StringComparison.CurrentCultureIgnoreCase)))
                        {
                            if (sTemp.ToUpper().Contains(" SUB ") || sTemp.ToUpper().Contains(" PROPERTY ") || sTemp.ToUpper().Contains(" FUNCTION ")
                                || sTemp.Trim().ToUpper().StartsWith("SUB ") || sTemp.Trim().ToUpper().StartsWith("PROPERTY ") || sTemp.Trim().ToUpper().StartsWith("FUNCTION "))
                            {
                                if (!(sTemp.ToUpper().Contains(" DECLARE ") && sTemp.ToUpper().Contains(" LIB ")))
                                {
                                    bIsDone = true;
                                    iLineFirstFunction = iLineTemp;
                                }
                            }
                        }

                        if (sTemp.StartsWith("OPTION"))
                        { iLineLastOption = iLineTemp; }

                        iLineTemp++;
                    }
                    else
                    { bIsDone = true; }
                }

                if (iLineNumber < iLineFirstFunction && iLineLastOption >= iLineNumber)
                { iLineNumber = iLineFirstFunction; }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref List<string> lstLines, int iLineNo)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref lstLines, ref vbComp, iLineNo);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines, int iLineNo)
        {
            try
            {
                VBA.VBComponent vbComp = ClsMisc.ActiveVBComponent();

                addCode(ref cLines, ref vbComp, iLineNo);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref List<string> lstLines, ref VBA.VBComponent VBComp, int iLineNo)
        {
            try
            {
                VBA.CodePane objCodePane = VBComp.CodeModule.CodePane;

                addLines(ref lstLines, ref objCodePane, ref iLineNo);

                //objCodePane.SetSelection(iLinePos, 1, iLinePos, 1);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addCode(ref ClsLinesOutputRapper cLines, ref VBA.VBComponent VBComp, int iLineNo)
        {
            try
            {
                VBA.CodePane objCodePane = VBComp.CodeModule.CodePane;

                addLines(ref cLines, ref objCodePane, ref iLineNo);

                //objCodePane.SetSelection(iLinePos, 1, iLinePos, 1);
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void modifyLines(ref List<ClsCodeMapper.strLine> lstLines, ref VBA.CodePane objCodePane, ref ClsCodeMapper cCodeMapper)
        {
            try
            {
                foreach(ClsCodeMapper.strLine objLine in lstLines)
                {

                    int iLineIndex = cCodeMapper.getLineNumber(objLine);

                    cCodeMapper.updateLine(iLineIndex, objLine);
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addLines(ref List<string> lstLines, ref VBA.CodePane objCodePane, ref int iLinePos)
        {
            try
            {
                ClsSettings cSettings = new ClsSettings();
                bool bIsFinished = false;
                int iNoOfCuts = 0;

                if (iLinePos == 0)
                { iLinePos = 1; }

                ClsMisc.removeReturnChar(ref lstLines);

                foreach (string sLineNew in lstLines)
                {
                    if (ClsMiscString.Left(sLineNew.TrimStart(), 1) == "'" || ClsMiscString.Left(sLineNew.ToUpper().TrimStart(), 3) == "REM")
                    {
                        //iLinePos++;
                        objCodePane.CodeModule.InsertLines(iLinePos, sLineNew);
                        iLinePos++;
                    }
                    else
                    {
                        int iCharCutOff = cSettings.InsertCode_Format_CharCutOffPoint;
                        int iNextIndenting = 0;
                        int iPosCut = 0;

                        List<ClsCodeMapper.enumLineType> lstLineTypes = new List<ClsCodeMapper.enumLineType>();

                        ClsCodeMapper.enumLineType eLineType = ClsCodeMapper.getLineType(sLineNew);

                        if (eLineType != ClsCodeMapper.enumLineType.eLineType_Unknown)
                        { lstLineTypes.Add(eLineType); }

                        findWhereToCutLine(ref cSettings, sLineNew, iCharCutOff, ref iPosCut, ref iNextIndenting, lstLineTypes);
                        //public static void findWhereToCutLine(ref ClsSettings cSettings, string sLine, int iCharCutOff, ref int iPosCut, ref int iNextIndenting, List<ClsCodeMapper.enumLineType> lstLineTypes)

                        string sLineSoFar = ClsMiscString.Left(sLineNew, iPosCut);
                        string sLineRemainer = ClsMiscString.Right(sLineNew, sLineNew.Length - iPosCut);
                        /*
                         * new indent is for new lines it's the previous open bracket from the cut.
                         * however if there is no previous open bracket then excluding the indent 
                         * it's the first white space that is not inclosed in double quotes
                         */
                        if (iPosCut == 0 || iPosCut >= sLineNew.Length - 1)
                        {
                            //try this randomly
                            //iLinePos++;
                            objCodePane.CodeModule.InsertLines(iLinePos, sLineNew);
                            iLinePos++;
                        }
                        else
                        {
                            bool bIsLineFunctionDeclare = false;
                            bool bIsLineEquals = false;

                            if (sLineNew.Trim().ToUpper().StartsWith("PUBLIC SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PRIVATE SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PUBLIC FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PRIVATE FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PUBLIC PROPERTY ", StringComparison.CurrentCultureIgnoreCase))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PRIVATE PROPERTY "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (sLineNew.Trim().ToUpper().StartsWith("PROPERTY ", StringComparison.CurrentCultureIgnoreCase))
                            { bIsLineFunctionDeclare = true; }

                            if (sLineNew.Contains('='))
                            { bIsLineEquals = true; }

                            iNoOfCuts++; //First line

                            string sLineOne = ClsMiscString.Left(sLineNew, iPosCut);
                            bIsFinished = false;

                            sLineOne += " _";

                            //iLinePos++;
                            objCodePane.CodeModule.InsertLines(iLinePos, sLineOne);
                            iLinePos++;

                            while (!bIsFinished)
                            {
                                int iPosNextCut = 0;

                                if (iNoOfCuts < 22)
                                { findNextCut(ref cSettings, sLineNew, iPosCut, ref iPosNextCut, ref iNextIndenting, bIsLineFunctionDeclare, bIsLineEquals); }
                                else
                                { iPosNextCut = 0; }

                                string sLineNext;// = sLineNew.Substring(iPosCut, iPosNextCut - iPosCut);

                                if (iPosNextCut == 0)
                                {
                                    sLineNext = ClsMiscString.Right(sLineNew, sLineNew.Length - iPosCut);
                                    sLineNext = sLineNext.PadLeft(iNextIndenting + sLineNext.Length);
                                    bIsFinished = true;
                                }
                                else
                                {
                                    iNoOfCuts++;

                                    sLineNext = sLineNew.Substring(iPosCut, iPosNextCut - iPosCut) + " _ ";
                                    sLineNext = sLineNext.PadLeft(iNextIndenting + sLineNext.Length);
                                }

                                //iLinePos++;
                                objCodePane.CodeModule.InsertLines(iLinePos, sLineNext);
                                iLinePos++;

                                if (iPosNextCut >= sLineNew.Length - 1)
                                { bIsFinished = true; }

                                iPosCut = iPosNextCut;
                            }
                        }
                        lstLineTypes = null;
                    }
                }

                cSettings = null;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public void addLines(ref ClsLinesOutputRapper cLines, ref VBA.CodePane objCodePane, ref int iLinePos)
        {
            try
            {
                ClsSettings cSettings = new ClsSettings();
                bool bIsFinished = false;
                bool bIsDoubleQuotes = false;
                int iNoOfCuts = 0;

                //ClsMisc.removeReturnChar(ref cLines);
                cLines.removeReturnChar();

                foreach (ClsLinesOutputRapper.strLineOut objLineNew in cLines.lines)
                {
                    if (ClsMiscString.Left(objLineNew.sLine.TrimStart(), 1) == "'" || ClsMiscString.Left(objLineNew.sLine.ToUpper().TrimStart(), 3) == "REM")
                    {
                        //iLinePos++;
                        objCodePane.CodeModule.InsertLines(iLinePos, objLineNew.sLine);
                        iLinePos++;
                    }
                    else
                    {
                        int iCharCutOff = cSettings.InsertCode_Format_CharCutOffPoint;
                        int iNextIndenting = 0;
                        int iPosCut = 0;

                        List<ClsCodeMapper.enumLineType> lstLineTypes = new List<ClsCodeMapper.enumLineType>();

                        ClsCodeMapper.enumLineType eLineType = ClsCodeMapper.getLineType(objLineNew.sLine);

                        if (eLineType != ClsCodeMapper.enumLineType.eLineType_Unknown)
                        { lstLineTypes.Add(eLineType); }

                        findWhereToCutLine(ref cSettings, objLineNew.sLine, iCharCutOff, ref iPosCut, ref iNextIndenting, lstLineTypes);
                        //public static void findWhereToCutLine(ref ClsSettings cSettings, string sLine, int iCharCutOff, ref int iPosCut, ref int iNextIndenting, List<ClsCodeMapper.enumLineType> lstLineTypes)

                        string sLineSoFar = ClsMiscString.Left(objLineNew.sLine, iPosCut);
                        string sLineRemainer = ClsMiscString.Right(objLineNew.sLine, objLineNew.sLine.Length - iPosCut);
                        /*
                         * new indent is for new lines it's the previous open bracket from the cut.
                         * however if there is no previous open bracket then excluding the indent 
                         * it's the first white space that is not inclosed in double quotes
                         */
                        if (iPosCut == 0 || iPosCut >= objLineNew.sLine.Length - 1)
                        {
                            //try this randomly
                            //iLinePos++;
                            objCodePane.CodeModule.InsertLines(iLinePos, objLineNew.sLine);
                            iLinePos++;
                        }
                        else
                        {
                            bool bIsLineFunctionDeclare = false;
                            bool bIsLineEquals = false;

                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PUBLIC SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PRIVATE SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PUBLIC FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PRIVATE FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PUBLIC PROPERTY ", StringComparison.CurrentCultureIgnoreCase))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PRIVATE PROPERTY "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("SUB "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("FUNCTION "))
                            { bIsLineFunctionDeclare = true; }
                            if (objLineNew.sLine.Trim().ToUpper().StartsWith("PROPERTY ", StringComparison.CurrentCultureIgnoreCase))
                            { bIsLineFunctionDeclare = true; }

                            if (objLineNew.sLine.Contains('='))
                            { bIsLineEquals = true; }

                            iNoOfCuts++; //First line

                            string sLineOne = ClsMiscString.Left(objLineNew.sLine, iPosCut);
                            bIsFinished = false;

                            sLineOne += " _";

                            //iLinePos++;
                            objCodePane.CodeModule.InsertLines(iLinePos, sLineOne);
                            iLinePos++;

                            while (!bIsFinished)
                            {
                                int iPosNextCut = 0;

                                if (iNoOfCuts < 22)
                                { findNextCut(ref cSettings, objLineNew.sLine, iPosCut, ref iPosNextCut, ref iNextIndenting, bIsLineFunctionDeclare, bIsLineEquals); }
                                else
                                { iPosNextCut = 0; }

                                string sLineNext;// = sLineNew.Substring(iPosCut, iPosNextCut - iPosCut);

                                if (iPosNextCut == 0)
                                {
                                    sLineNext = ClsMiscString.Right(objLineNew.sLine, objLineNew.sLine.Length - iPosCut);
                                    sLineNext = sLineNext.PadLeft(iNextIndenting + sLineNext.Length);
                                    bIsFinished = true;
                                }
                                else
                                {
                                    iNoOfCuts++;

                                    sLineNext = objLineNew.sLine.Substring(iPosCut, iPosNextCut - iPosCut) + " _ ";
                                    sLineNext = sLineNext.PadLeft(iNextIndenting + sLineNext.Length);
                                }

                                //iLinePos++;
                                objCodePane.CodeModule.InsertLines(iLinePos, sLineNext);
                                iLinePos++;

                                if (iPosNextCut >= objLineNew.sLine.Length - 1)
                                { bIsFinished = true; }

                                iPosCut = iPosNextCut;
                            }
                        }
                        lstLineTypes = null;
                    }
                }

                cSettings = null;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public static void findWhereToCutLine(ref ClsSettings cSettings, string sLine, int iCharCutOff, ref int iPosCut, ref int iNextIndenting, List<ClsCodeMapper.enumLineType> lstLineTypes)
        {
            try
            {
                sLine = sLine.TrimEnd();

                if (sLine.Trim() != "")
                {
                    int iResult = sLine.Length - 1;
                    /*
                     * 1) counter iPos increaments from 0
                     * 2) boolean flag keeps track of if it is in quotes or not
                     * 3) flag in (2) is disabled in comments
                     * 4) when the iCharCutOff char is reached then look for the next place to cut.
                     */
                    enumFormatLineCutMethodology eFormatLineCutMethodology = cSettings.FormatLineCutMethodology;

                    if (ClsCodeMapper.countIF(lstLineTypes, ClsCodeMapper.enumLineType.eLineType_FunctionName) > 0)
                    {
                        bool bIsOk = true;
                        
                        if (!sLine.Contains('('))
                        { bIsOk = false; }
                        else if (!ClsMiscString.containsOutsideQuotes(sLine, "("))
                        { bIsOk = false; }

                        if (bIsOk)
                        {
                            //int iPosFirstBracket = sLine.First(x => x == '(');
                            int iPosFirstBracket = sLine.IndexOf('(');
                            
                            iNextIndenting = iPosFirstBracket + 1;

                            int iPos = 0;
                            bool bIsInQuotes = false;
                            bool bIsFinished = false;
                            int iBracketCounterCurved = 0;
                            int iBracketCounterCurly = 0;
                            int iBracketCounterSquare = 0;

                            while (!bIsFinished)
                            {
                                char cCurrChar = sLine[iPos];

                                if (cCurrChar == '"')
                                { bIsInQuotes = !bIsInQuotes; }

                                if (!bIsInQuotes)
                                {

                                    switch (cCurrChar)
                                    {
                                        case '(':
                                            iBracketCounterCurved++;
                                            break;
                                        case '[':
                                            iBracketCounterSquare++;
                                            break;
                                        case '{':
                                            iBracketCounterCurly++;
                                            break;
                                        case ')':
                                            iBracketCounterCurved--;
                                            break;
                                        case ']':
                                            iBracketCounterSquare--;
                                            break;
                                        case '}':
                                            iBracketCounterCurly--;
                                            break;
                                    }

                                    switch (eFormatLineCutMethodology)
                                    {
                                        case enumFormatLineCutMethodology.eFmtLineCut_AfterXChar:
                                            if (iBracketCounterCurved == 1 && iBracketCounterSquare == 0 && iBracketCounterCurly == 0)
                                            {
                                                if (cCurrChar == ',')
                                                {
                                                    if (iPos > cSettings.InsertCode_Format_CharCutOffPoint) 
                                                    {
                                                        if (sLine.Length > iPos + 1)
                                                        { iPosCut = iPos + 1; }
                                                        else
                                                        { iPosCut = iPos; }
                                                        bIsFinished = true;
                                                    }
                                                }
                                            }
                                            break;
                                        case enumFormatLineCutMethodology.eFmtLineCut_AtFirstBracket:
                                            if (iBracketCounterCurved == 1 && iBracketCounterSquare == 0 && iBracketCounterCurly == 0)
                                            {
                                                if (cCurrChar == ',')
                                                {
                                                    if (sLine.Length > iPos + 1)
                                                    { iPosCut = iPos + 1; }
                                                    else
                                                    { iPosCut = iPos; }
                                                    bIsFinished = true;
                                                }
                                            }
                                            break;
                                        case enumFormatLineCutMethodology.eFmtLineCut_None:
                                        default:
                                            break;
                                    }
                                }

                                if (iPos < sLine.Length - 1)
                                { iPos++; }
                                else
                                { bIsFinished = true; }
                            }
                        }
                    }
                    else
                    {
                        int iPos = 0;
                        bool bIsInQuotes = false;
                        bool bIsFinished = false;
                        bool bIsComment = false;

                        switch (eFormatLineCutMethodology)
                        {
                            case enumFormatLineCutMethodology.eFmtLineCut_AfterXChar:
                                if (ClsMiscString.Left(ref sLine, cSettings.InsertCode_Format_CharCutOffPoint).Contains('"'))
                                { iPos = sLine.Length - 1; }
                                //{ iPos = sLine.Length - sLine.TrimStart().Length + 1; }
                                else
                                { iPos = cSettings.InsertCode_Format_CharCutOffPoint; }

                                //find cut
                                while (!bIsFinished)
                                {
                                    iPos++;
                                    //if we get to the end of the line then just finish
                                    if (sLine.Length < iPos + 1)
                                    { bIsFinished = true; }
                                    else
                                    {
                                        char cCurrChar = sLine[iPos];

                                        //if we get a double quote switch the flag
                                        if (cCurrChar == '"')
                                        { bIsInQuotes = !bIsInQuotes; }

                                        if (!bIsInQuotes)
                                        {
                                            if (cCurrChar == '\'')
                                            {
                                                bIsComment = true;
                                                bIsFinished = true;
                                            }
                                            else
                                            {
                                                //if the double quote flag is not set and we get a comma then return the position.
                                                if (iPos > cSettings.InsertCode_Format_CharCutOffPoint & cCurrChar == ' ')
                                                //if (iPos > cSettings.InsertCode_Format_CharCutOffPoint & (cCurrChar == ',' || cCurrChar == ' '))
                                                {
                                                    iPosCut = iPos;
                                                    bIsFinished = true;
                                                }
                                            }
                                        }
                                    }
                                }

                                int iBracketCounterCurved = 0;
                                int iBracketCounterCurly = 0;
                                int iBracketCounterSquare = 0;

                                //find next indenting
                                if (iPosCut != 0)
                                {
                                    if (ClsMiscString.containsOutsideQuotes(ClsMiscString.Left(ref sLine, iPosCut), "="))
                                    { iNextIndenting = ClsMiscString.Left(ref sLine, iPosCut).IndexOf('='); }
                                    else if (ClsMiscString.Left(ref sLine, iPosCut).Trim().ToUpper().StartsWith("Dim ", StringComparison.CurrentCultureIgnoreCase) )
                                    { iNextIndenting = ClsMiscString.Left(ref sLine, iPosCut).ToLower().IndexOf("dim ") + 4; }
                                    else if (ClsMiscString.Left(ref sLine, iPosCut).Trim().ToUpper().StartsWith("const ", StringComparison.CurrentCultureIgnoreCase))
                                    { iNextIndenting = ClsMiscString.Left(ref sLine, iPosCut).ToLower().IndexOf("const ") + 6; }
                                    else if (ClsMiscString.Left(ref sLine, iPosCut).Trim().ToUpper().StartsWith("private ", StringComparison.CurrentCultureIgnoreCase)
                                        & !(sLine.ToLower().Contains(" sub ") | sLine.ToLower().Contains(" function ") | sLine.ToLower().Contains(" property ")))
                                    { iNextIndenting = ClsMiscString.Left(ref sLine, iPosCut).ToLower().IndexOf("private ") + 8; }
                                    else if (ClsMiscString.Left(ref sLine, iPosCut).Trim().ToUpper().StartsWith("public ", StringComparison.CurrentCultureIgnoreCase)
                                        & !(sLine.ToLower().Contains(" sub ") | sLine.ToLower().Contains(" function ") | sLine.ToLower().Contains(" property ")))
                                    { iNextIndenting = ClsMiscString.Left(ref sLine, iPosCut).ToLower().IndexOf("public ") + 7; }
                                    else
                                    {
                                        bIsFinished = false;
                                        iPos = iPosCut;
                                        while (!bIsFinished)
                                        {
                                            iPos--;

                                            if (iPos == 0)
                                            {
                                                bIsFinished = true;
                                                iNextIndenting = 0;
                                            }
                                            else
                                            {
                                                char cCurrChar = (char)sLine[iPos];

                                                if (cCurrChar == '"')
                                                { bIsInQuotes = !bIsInQuotes; }

                                                if (!bIsInQuotes)
                                                {
                                                    if (iBracketCounterCurved == 0 & iBracketCounterCurved == 0 & iBracketCounterSquare == 0)
                                                    {
                                                        if (cCurrChar == '(' | cCurrChar == '[' | cCurrChar == '{' | cCurrChar == ' ')
                                                        {
                                                            iNextIndenting = iPos + 1;
                                                            bIsFinished = true;
                                                        }
                                                    }

                                                    //note: we are moving backwards through the string so we should have the + and - the other way around in the switch
                                                    switch (cCurrChar)
                                                    {
                                                        case '(':
                                                            iBracketCounterCurved--;
                                                            break;
                                                        case '[':
                                                            iBracketCounterSquare--;
                                                            break;
                                                        case '{':
                                                            iBracketCounterCurly--;
                                                            break;
                                                        case ')':
                                                            iBracketCounterCurved++;
                                                            break;
                                                        case ']':
                                                            iBracketCounterSquare++;
                                                            break;
                                                        case '}':
                                                            iBracketCounterCurly++;
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                break;
                            case enumFormatLineCutMethodology.eFmtLineCut_AtFirstBracket:
                                bool bCanCutOnSpace = true;

                                iBracketCounterCurved = 0;
                                iBracketCounterCurly = 0;
                                iBracketCounterSquare = 0;

                                iPos = sLine.Length - sLine.TrimStart().Length + 1;

                                if (sLine.Contains("="))
                                { bCanCutOnSpace = false; }

                                if (sLine.Trim().Length > 3)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 3).ToUpper())
                                    {
                                        case "IF ":
                                        case "DO ":
                                        case "ON ":
                                            bCanCutOnSpace = false;
                                            break;
                                        case "REM":
                                            bIsFinished = true;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 4)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 4).ToUpper())
                                    {
                                        case "FOR ":
                                        case "SET ":
                                        case "GET ":
                                        case "LET ":
                                        case "DIM ":
                                        case "SUB ":
                                        case "END ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 5)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 5).ToUpper())
                                    {
                                        case "GOTO ":
                                        case "LOOP ":
                                        case "NEXT ":
                                        case "ENUM ":
                                        case "WITH ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 6)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 6).ToUpper())
                                    {
                                        case "GOSUB ":
                                        case "WHILE ":
                                        case "UNTIL ":
                                        case "CONST ":
                                        case "REDIM ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 7)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 7).ToUpper())
                                    {
                                        case "ELSEIF ":
                                        case "PUBLIC ":
                                        case "FRIEND ":
                                        case "OPTION ":
                                        case "RETURN ":
                                        case "SELECT ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 8)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 8).ToUpper())
                                    {
                                        case "PRIVATE ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 9)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 9).ToUpper())
                                    {
                                        case "PROPERTY ":
                                        case "FUNCTION ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                if (sLine.Trim().Length > 10)
                                {
                                    switch (ClsMiscString.Left(sLine.Trim(), 10).ToUpper())
                                    {
                                        case "PROTECTED ":
                                            bCanCutOnSpace = false;
                                            break;
                                    }
                                }

                                //if begins in "Call "
                                if (sLine.Trim().Length > 5)
                                {
                                    if (ClsMiscString.Left(sLine.Trim(), 5).ToUpper() == "CALL ")
                                    { iPos = iPos + 5; }
                                }

                                while (!bIsFinished)
                                {
                                    iPos++;
                                    //if we get to the end of the line then just finish
                                    if (sLine.Length < iPos + 1)
                                    { bIsFinished = true; }

                                    if (!bIsFinished)
                                    {
                                        char cCurrChar = sLine[iPos];

                                        //if we get a double quote switch the flag
                                        if (cCurrChar == '"')
                                        { bIsInQuotes = !bIsInQuotes; }

                                        if (!bIsInQuotes)
                                        {
                                            if (iNextIndenting == 0)
                                            {
                                                //if iNextIndenting = 0 => we only want the first bracket
                                                if (cCurrChar == '(' || cCurrChar == '[' || cCurrChar == '{' || (cCurrChar == ' ' && bCanCutOnSpace))
                                                {
                                                    if (iPos < sLine.Length - 1)
                                                    {
                                                        char cNextChar = sLine[iPos + 1];

                                                        if (!(cNextChar == ')' || cNextChar == ']' || cNextChar == '}'))
                                                        {
                                                            iBracketCounterCurved = 0;
                                                            iBracketCounterCurly = 0;
                                                            iBracketCounterSquare = 0;
                                                            iNextIndenting = iPos + 1;
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                switch (cCurrChar)
                                                {
                                                    case '(':
                                                        iBracketCounterCurved--;
                                                        break;
                                                    case '[':
                                                        iBracketCounterSquare--;
                                                        break;
                                                    case '{':
                                                        iBracketCounterCurly--;
                                                        break;
                                                    case ')':
                                                        iBracketCounterCurved++;
                                                        break;
                                                    case ']':
                                                        iBracketCounterSquare++;
                                                        break;
                                                    case '}':
                                                        iBracketCounterCurly++;
                                                        break;
                                                }

                                                if (iBracketCounterCurved == 0 & iBracketCounterSquare == 0 & iBracketCounterCurly == 0)
                                                {
                                                    if (cCurrChar == ',')
                                                    {
                                                        if (sLine.Length > iPos + 1)
                                                        {
                                                            char cNextChar = (char)sLine.Substring(iPos + 1, 1)[0];

                                                            if (cNextChar == ' ')
                                                            { iPosCut = iPos + 1; }
                                                            else
                                                            { iPosCut = iPos; }
                                                        }
                                                        else
                                                        { iPosCut = iPos; }
                                                        bIsFinished = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                break;
                            default:
                                iPosCut = sLine.Length; //-1
                                iNextIndenting = 0;
                                break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public static void findNextCut(ref ClsSettings cSettings, string sLineOrig, int iPosCutPrevious, ref int iPosNextCut, ref int iNextIndent, bool bIsFunctionDeclare, bool bIsEquals) 
        {
            try
            {
                int iBracketCounterCurved = 0;
                int iBracketCounterCurly = 0;
                int iBracketCounterSquare = 0;
                bool bIsInQuotes = false;
                int iPos = iPosCutPrevious;
                bool bIsFinished = false;

                //iPos++;
                //iPos++;

                switch (cSettings.FormatLineCutMethodology)
                {
                    case enumFormatLineCutMethodology.eFmtLineCut_AfterXChar:
                        iPosNextCut = 0;

                        while (!bIsFinished)
                        {
                            //if iPos gets to end of line then finish
                            if (sLineOrig.Length < iPos + 1)
                            { bIsFinished = true; }
                            else
                            {
                                char cCurrChar = (char)sLineOrig[iPos];

                                //only cut outside the string
                                if (cCurrChar == '"')
                                { bIsInQuotes = !bIsInQuotes; }

                                if (!bIsInQuotes)
                                {
                                    //when we get to a comment don't cut
                                    if (cCurrChar == '\'')
                                    { bIsFinished = true; }

                                    //count brackets
                                    switch (cCurrChar)
                                    {
                                        case '(':
                                            iBracketCounterCurved++;
                                            break;
                                        case ')':
                                            iBracketCounterCurved--;
                                            break;
                                        case '{':
                                            iBracketCounterCurly++;
                                            break;
                                        case '}':
                                            iBracketCounterCurly--;
                                            break;
                                        case '[':
                                            iBracketCounterSquare++;
                                            break;
                                        case ']':
                                            iBracketCounterSquare--;
                                            break;
                                    }

                                    //if length of line is over limit
                                    if (((iPos - iPosCutPrevious) + iNextIndent) > cSettings.InsertCode_Format_CharCutOffPoint)
                                    {
                                        //if cut is not in brackets and char is space or comma
                                        if (iBracketCounterCurly <= 0 && iBracketCounterCurved <= 0 && iBracketCounterSquare <= 0)
                                        {
                                            if ((bIsFunctionDeclare && cCurrChar == ',') || (bIsEquals && cCurrChar == ' ') || (!bIsFunctionDeclare && !bIsEquals && (cCurrChar == ',' || cCurrChar == ' ')))
                                            //if (iBracketCounterCurly <= 0 & iBracketCounterCurved <= 0 & iBracketCounterSquare <= 0 & (cCurrChar == ',' | cCurrChar == ' '))
                                            {
                                                //must make sure that something will be on the new line.
                                                if (ClsMiscString.Right(ref sLineOrig, sLineOrig.Length - iPos).Trim() != "")
                                                {
                                                    if (iPos - 2 >= iPosCutPrevious)
                                                    {
                                                        //iPosNextCut = iPos;
                                                        if (sLineOrig.Length > iPos + 1)
                                                        { iPosNextCut = iPos + 1; }
                                                        else
                                                        { iPosNextCut = iPos; }
                                                        bIsFinished = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            iPos++;
                        }
                        break;
                    case enumFormatLineCutMethodology.eFmtLineCut_AtFirstBracket:
                        iPosNextCut = 0;

                        while (!bIsFinished)
                        {
                            if (sLineOrig.Length < iPos + 1)
                            { bIsFinished = true; }
                            else
                            {
                                char cCurrChar = (char)sLineOrig[iPos];

                                if (cCurrChar == '"')
                                { bIsInQuotes = !bIsInQuotes; }

                                if (!bIsInQuotes)
                                {
                                    switch (cCurrChar)
                                    {
                                        case '(':
                                            iBracketCounterCurved++;
                                            break;
                                        case ')':
                                            iBracketCounterCurved--;
                                            break;
                                        case '{':
                                            iBracketCounterCurly++;
                                            break;
                                        case '}':
                                            iBracketCounterCurly--;
                                            break;
                                        case '[':
                                            iBracketCounterSquare++;
                                            break;
                                        case ']':
                                            iBracketCounterSquare--;
                                            break;
                                    }

                                    if (iBracketCounterCurly <= 0 && iBracketCounterCurved <= 0 && iBracketCounterSquare <= 0)
                                    {
                                        if ((bIsFunctionDeclare && cCurrChar == ',') || (bIsEquals && cCurrChar == ' ') || (!bIsFunctionDeclare && !bIsEquals && (cCurrChar == ',' || cCurrChar == ' ')))
                                        {
                                            if (iPos - 2 >= iPosCutPrevious)
                                            {
                                                if (sLineOrig.Length > iPos + 2)
                                                {
                                                    char cNextChar = sLineOrig[iPos + 1];

                                                    switch (cNextChar)
                                                    {
                                                        case '&':
                                                        case '+':
                                                            //do nothing
                                                            break;
                                                        case ' ':
                                                            iPosNextCut = iPos + 1;
                                                            break;
                                                        default:
                                                            iPosNextCut = iPos;
                                                            break;
                                                    }
                                                }
                                                else
                                                { iPosNextCut = iPos; }
                                                bIsFinished = true;
                                            }
                                        }
                                    }
                                }
                            }
                            iPos++;
                        }
                        break;
                    case enumFormatLineCutMethodology.eFmtLineCut_None:
                        break;
                }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
            }
        }

        public VBA.VBComponent addModule(string sName, VBA.vbext_ComponentType eType)
        {
            try
            {
                Excel.Workbook wrk = ClsMisc.ActiveWorkBook();
                VBA.VBComponent vbComp = wrk.VBProject.VBComponents.Add(eType);
                vbComp.Name = sName;

                return vbComp;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);
                
                return null;
            }
        }

        public VBA.VBComponent getModule(string sName)
        {
            try
            {
                Excel.Workbook wrk = ClsMisc.ActiveWorkBook();
                VBA.VBComponent vbComp;
                bool bIsFound = false;
                vbComp = null;

                foreach (VBA.VBComponent vbTemp in wrk.VBProject.VBComponents)
                {
                    if (vbTemp.Name.Trim().ToLower() == sName.Trim().ToLower())
                    { 
                        vbComp = vbTemp;
                        bIsFound = true;
                    }
                }

                if (bIsFound)
                { return vbComp; }
                else
                { return null; }
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                return null;
            }
        }
        /*
        public string getNextSampleFunctionName(string sSuffix)
        {
            try
            {
                int iCounter = 0;

                string sTemp = csSampleFunctionNamePrefix + sSuffix;

                while (this.cCodeMapperWrk.functionNameExists(sTemp))
                {
                    iCounter++;
                    sTemp = csSampleFunctionNamePrefix + sSuffix + iCounter.ToString();
                }

                return sTemp;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                return string.Empty;
            }
        }
        */
        public string getNextSampleFunctionName(ref ClsCodeMapperWrk cCodeMapperWrk, string sSuffix)
        {
            try
            {
                int iCounter = 0;

                string sTemp = csSampleFunctionNamePrefix + sSuffix;

                while (cCodeMapperWrk.functionNameExists(sTemp))
                {
                    iCounter++;
                    sTemp = csSampleFunctionNamePrefix + sSuffix + iCounter.ToString();
                }

                return sTemp;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                return string.Empty;
            }
        }

        public string getNextSampleFunctionName(ref ClsCodeMapper cCodeMapper, string sSuffix)
        {
            try
            {
                int iCounter = 0;

                string sTemp = csSampleFunctionNamePrefix + sSuffix;

                while (cCodeMapper.getLstFunctions().Exists(x => x.sName.ToUpper().Trim() == sTemp.ToUpper().Trim()))
                {
                    iCounter++;
                    sTemp = csSampleFunctionNamePrefix + sSuffix + iCounter.ToString();
                }

                return sTemp;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = string.Empty;

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                return string.Empty;
            }
        }

        public string getNextSampleFunctionName(ref ClsCodeMapper cCodeMapper) 
        {
            try
            {
                string sTemp = getNextSampleFunctionName(ref cCodeMapper, string.Empty);

                return sTemp;
            }
            catch (Exception ex)
            {
                MethodBase mbTemp = MethodBase.GetCurrentMethod();

                string sMessage = "";

                sMessage += "Add-in: " + mbTemp.ReflectedType.Name + "\n\r";
                sMessage += "Module Name: " + mbTemp.Module.Name + "\n\r";
                sMessage += "Function Name: " + mbTemp.Name + "\n\r\n\r";
                sMessage += ex.Message;

                MessageBox.Show(text: sMessage, caption: "Error", buttons: MessageBoxButtons.OK, icon: MessageBoxIcon.Error);

                return string.Empty;
            }
        }

        private void fixedReturnCharactors(ref List<string> lstLines)
        {

        }

        private void fixedReturnCharactors(ref ClsLinesOutputRapper cLines)
        {

        }
    }
}
